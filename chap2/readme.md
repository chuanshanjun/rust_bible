### 2.2 基本类型
### 2.2.1 数值类型

* Rust整形默认使用`i32`

**整型溢出**
* debug模式编译时，Rust会检查整型溢出，若存在则崩溃
* `--release`参数进行构建时，Rust **不**检测溢出。如有Rust会按照补码循环溢出

**浮点类型**
* `f32`和`f64`，默认浮点类型是`f64`，在现代CPU中它的速度与`f32`几乎相同，但精度更好

需要遵守以下准则:  
* 避免在浮点数上测试相等性
* 当结果在数学上可能存在未定义时，需要格外小心

```Rust
// 因为二进制精度的问题，导致0.1+0.2并不严格等于0.3
// 它们可能在小数点N位后存在误差。
// 非要比较可以采用 (0.1_f64 + 0.2 - 0.3).abs() < 0.00001
fn main() {
  // 断言0.1 + 0.2与0.3相等
  assert!(0.1 + 0.2 == 0.3);
}
```

**字符类型**
所有`Unicode`值都可以作为Rust字符，由于`Unicode`都是4个字节编码，因此字符类型也是占用4个字节。字符只能使用 **``** 来表示，**""** 留给字符串。

**布尔**
两种:`true` 和 `false`,布尔值占用内存1个字节

**单元类型**
单元类型就是`()`,例如 `fn main()` 函数返回单元类型`()`, 也可使用`()`作为`map`的值,表示我们不关注具体的值,只关注`key`。这种用法和Go语言的struct{}类似,可以作为一个值用来站位,但是完全**不占用**任何内存

**语句和表达式**
```Rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```
语句会执行一些操作但是不会返回一个值,而表达式会在求值后返回一个值，因此在上述函数体的三行代码中，前两行是语句，最后一行是表达式。
对于Rust语言而言,**这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念**,但是对于很多其它语言而言，这两个往往无需区分。基于表达式是函数式语言的重要特征,**表达式总要返回值**

由于`let`是语句，因此不能将`let`语句赋值给其它值，如下形式是错误的:
```Rust
let b = (let a = 8);
```

**表达式**
表达式可以成为语句的一部分,例如`let y = 6`中, `6` 就是一个表达式,它在求值后返回一个值 `6`  
调用一个函数是表达式,因为会返回一个值,调用宏也是表达式,用花括号包裹最终返回一个值的语句块也是表达式,总之,能返回值,它就是表达式
```Rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
``` 
```Rust
{
    let x = 3;
    x + 1
}
```
该语句块是表达式的原因是:它的最后一行是表达式,返回了`x + 1`的值,注意 `x + 1` 不能以分号结尾,否则就会从表达式变成语句,**表达式不能包含分号**,这一点非常重要,一旦你在表达式后加上分号,它就会变成一条语句,再也**不会**返回一个值,请牢记！

最后,表达式如果不返回任何值,会隐式地返回一个`()`
```Rust
// assert_eq! 宏后面可加可不加 分号
fn main() {
    assert_eq!(ret_unit_type(), ())
}

fn ret_unit_type() {
    let x = 1;
    // if 语句块也是一个表达式，因此可以用于赋值，也可以直接返回
    if (x > 1) {

    }
}
```

**函数**

**无返回值**
单元类型`()`,是一个零长度地元组，它没啥用，但是可以用来表达一个函数没有返回值:  
* 函数没有返回值,那么返回一个`()`
* 通过`;`结尾地表达式返回一个`()`
```Rust
//例如下面的 report 函数会隐式返回一个 ()：
fn report<T: Debug>(item: T) {
  println!("{:?}", item);

}
// 与上面的函数返回值相同，但是下面的函数显式的返回了 ()：
fn clear(text: &mut String) -> () {
  *text = String::from("");
}
// !注意表达式加;号 返回的是()
fn add(x:u32,y:u32) -> u32 {
    x + y;
}
```

**所有权**  
重要规则
* 1. Rust中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 3. 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

**简单介绍String类型**
`let s = "hello"`, `s`是被硬编码进程序里的字符串值(类型为&str)。字符串字面值很方便，但是它并不适用于所有场景。原因有二：
* **字符串字面值不可变**，因为被硬编码到程序代码中
* 并非所有字符串的值都能在编写代码时得知

Rust提供动态字符串类型:`String`,该类型被分配到堆上,因此可以动态伸缩,也就能存储在编译时大小未知的文本。
```Rust
let s = String::from("hello");
```
`::`是一种调用操作符,这里表示调用`String`中的`from`方法,因为`String`存储在堆上是动态的,你可以修改。

当变量离开作用域后,Rust会自动调用`drop`函数并清理变量的堆内存。不过由于两个`String`变量指向了同一位置。这就有一个问题:当`s1`和`s2`离开作用域,它们都会尝试释放相同的内存。这是一个叫**二次释放(double free)**的错误，也是之前提到过的内存安全性BUG之一。两次释放(相同)内存会导致内存污染，它可能会导致潜在的安全漏洞。  
因此,Rust这样解决问题:**当`s1`赋予`s2`后,Rust认为`s1`不再有效,因此也无需在`s1`离开作用域后`drop`任何东西,这就是把所有权`s1`转移给了`s2`,`s1`在被赋予`s2`后就马上失效了。

**克隆(深拷贝)**
首先,**Rust永远也不会自动创建数据的"深拷贝"**。因此，任何**自动**的复制都不是深拷贝，可以被认为对运行时性能影响较小。  
如有我们**确实**需要深度复制`String`中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫`clone`的方法。

如果代码性能无关紧要，例如初始化程序时，或者在某段时间只会执行一次时，你可以使用`clone`来简化编程。但是对于执行较为频繁的代码(热点代码)，使用`clone`会极大的降低程序性能,需要小心使用！

**拷贝(浅拷贝)**
浅拷贝只发生在栈上,因此性能很高,在日常编程中,浅拷贝无处不在。

```Rust
let x = 5;
let y = x;
```
像整型这样的基本类型在编译时已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量`y`后使`x`无效(`x`,`y`都仍然有效)。换句话说，这里没有深浅拷贝的区别，因此这里调用`clone`并不会与通常的浅拷贝有什么不同，我们可以不用管它(可以理解成在栈上做了深拷贝)。

Rust有一个叫做`Copy`的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有`Copy`特征,一个旧的变量在被赋值给其它变量后仍然可用。

**函数传值与返回**  
将值传递给函数,一样会发生`移动`或者`复制`,就跟`let`语句一样

**引用与借用**
通过`&s1`语法,我们创建了一个**指向s1的引用**,但是并不拥有它。因为并不拥有这个值,当引用离开作用域后,其指指向的值也不会被放弃。

正如变量默认不可变一样，引用指向的默认值也是不可变的。

**可变引用同时只能存在一个**
**同一个作用域,特定数据只能有一个可变引用：**
```Rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```
第一个可变借用`r1`必须要持续到最后一次使用的位置`println!`,在`r1`
创建和最后一次使用之间,我们又尝试创建第二个可变引用`r2`  
这种限制的好处就是使Rust在编译期就避免数据竞争,数据竞争可由以下行为造成:
* 两个或更多的指针同时访问同一数据 
* 至少一个指针被用来写入数据
* 没有同步数据访问的机制  
数据竞争会导致未定义行为,这种行为很可能超出我们的预期,难以在运行时追踪,并且难以诊断和修复。  
很多时候,大括号可以帮我们解决一些编译不通过的问题,通过手动限制变量的作用域:
```Rust
let mut s = String::from("hello");
{
    let r1 = &mut s;
} // r1 在这里离开了作用域,所以我们完全可以创建一个新的引用

let r2 = &mut s;
```

**可变引用与不可变引用不能同时存在**  
```Rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题 
```
正在借用不可变引用的用户,肯定不希望他借用的东西,被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数,每个人都只读这一份数据而不做修改,因此不用担心数据被污染。
```
注意,引用的作用域s从创建开发,一直持续到它最后一次使用的地方,这个跟变量的作用域有所不同,变量的作用域从创建持续到某一个花括号}
```

**借用规则总结**  
* 同一时刻，你只能拥有要么一个可变引用,要么任意多个不可变引用
* 引用必须总是有效的

**字符串**

**字符串字面量是切片**

Rust中的字符是Unicode类型,因此每个字符占据4个字节内存空间,但是在字符串中不一样,字符串是UTF-8编码,也就是字符串中的字符所占的字节数是变化的(1-4),这样有助于大幅降低字符所占用的内存空间。

Rust在语言级别,只有一种字符串类型:`str`,它通常是以引用类型出现`&str`,也就是上文提到的字符串切片。虽然语言级别只有上述的`str`类型,但是在标准库里，还有多种不同用途的字符串类型,其中使用最广的是`String`类型。

`str`类型是硬编码进可执行文件,无法被修改,但是`String`则是一个可增长、可改变且具有所有权的UTF-8编码字符串,**当Rust用户提到字符串时，往往指的就是`String`类型和`&str`字符串切片类型,这两个类型都是UTF-8编码**

**String与&Str的转换**
两种从`&str`类型生成`String`类型的操作:
* String::from("hello, world")
* "hello, world".to_string()

`String`类型转换为`&str`类型,取引用即可
```Rust
fn main() {
    let s = String::from("hello, world!");
    say_hello(&s);
    say_hello(&s[..]);
    say_hello(s.as_str());
}

fn say_hello(s: &str) {
    println!("{}", s);
}
```

**深入字符串内部**
字符串的底层的数据存储格式实际上是[u8],一个字节数组.对于`let hello = String::from("hola");`这行代码来说,`Hola`的长度是`4`字节,因为"Hola"中的每个字母在UTF-8编码中仅占用1个字节,但是对于中文则不是,因为大部分常用汉字在UTF-8中的长度是`3`字节.

**字符串切片**
字符串切片是非常危险的操作,因为切片的索引是通过字节来进行的,但是字符串又是UTF-8编码,因此你无法保证索引的字节刚好落在字符的边界上

**操作字符串**

**追加(Push)**
在字符串尾部可以使用`push()`方法追加字符`char`,也可以使用`push_str()`方法追加字符串字面量。这两个方法都是**在原有的字符串上追加,并不会返回新的字符串。** 由于字符串追加操作要修改原来的字符串，则字符串必须是可变的,即**字符串变量必须由`mut`关键字修饰**

